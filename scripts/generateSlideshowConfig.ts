import * as fs from 'fs';
import * as path from 'path';
import { getAudioDurationInSeconds } from 'get-audio-duration';

const SCRIPT_FILE = path.join(process.cwd(), 'script_final.md');
const VOICES_DIR = path.join(process.cwd(), 'public', 'voices');
const OUTPUT_FILE = path.join(process.cwd(), 'src', 'data', 'slideshowConfig.ts');
const FPS = 30;

interface SlideItem {
  id: string;
  narration: string;
  slidePath: string;
  voicePath: string;
  audioDurationFrames: number;
}

interface ParsedScript {
  id: string;
  narration: string;
}

// script_final.mdを解析
function parseScriptFile(): ParsedScript[] {
  const content = fs.readFileSync(SCRIPT_FILE, 'utf-8');
  const lines = content.split('\n');
  const items: ParsedScript[] = [];

  let currentId: string | null = null;

  for (const line of lines) {
    const idMatch = line.match(/\[([S]\d+)\]/);
    if (idMatch) {
      currentId = idMatch[1];
      continue;
    }

    if (line.trim().startsWith('NARRATOR:')) {
      continue;
    }

    if (currentId && line.trim() && !line.trim().startsWith('[')) {
      items.push({
        id: currentId,
        narration: line.trim(),
      });
      currentId = null;
    }
  }

  return items;
}

// 音声ファイルの長さを取得
async function getAudioDuration(audioPath: string): Promise<number> {
  try {
    const duration = await getAudioDurationInSeconds(audioPath);
    return Math.ceil(duration * FPS);
  } catch (error) {
    console.error(`音声ファイルの読み込みに失敗: ${audioPath}`);
    return 0;
  }
}

// メイン処理
async function main() {
  console.log('=========================================');
  console.log('スライドショー設定ファイル生成');
  console.log('=========================================\n');

  const parsedItems = parseScriptFile();
  console.log(`解析結果: ${parsedItems.length}件\n`);

  const slides: SlideItem[] = [];
  let totalFrames = 0;

  for (const item of parsedItems) {
    const voiceFilePath = path.join(VOICES_DIR, `${item.id}.wav`);

    if (!fs.existsSync(voiceFilePath)) {
      console.error(`❌ 音声ファイルが見つかりません: ${item.id}.wav`);
      continue;
    }

    const audioDurationFrames = await getAudioDuration(voiceFilePath);
    console.log(`  ✓ ${item.id}: ${(audioDurationFrames / FPS).toFixed(2)}秒 (${audioDurationFrames}フレーム)`);

    slides.push({
      id: item.id,
      narration: item.narration,
      slidePath: `slide/${item.id}.png`,
      voicePath: `voices/${item.id}.wav`,
      audioDurationFrames,
    });

    totalFrames += audioDurationFrames;
  }

  console.log(`\n総フレーム数: ${totalFrames} (${(totalFrames / FPS).toFixed(2)}秒)\n`);

  // TypeScriptファイルを生成
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const fileContent = `// This file is auto-generated by scripts/generateSlideshowConfig.ts
// Do not edit manually

import { SlideshowConfig } from '../types/slideshow';

export const slideshowConfig: SlideshowConfig = {
  slides: ${JSON.stringify(slides, null, 2)},
  totalFrames: ${totalFrames},
};
`;

  fs.writeFileSync(OUTPUT_FILE, fileContent, 'utf-8');

  console.log('=========================================');
  console.log('✅ スライドショー設定ファイルを生成しました');
  console.log(`出力先: ${OUTPUT_FILE}`);
  console.log('=========================================');
}

main();
